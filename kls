#!/usr/bin/env python3
import curses, subprocess

SCREEN = curses.initscr()  # инициализация экрана
SELECTED, SELECTED_WITH_SEARCH, NOT_SELECTED, NOT_SELECTED_WITH_SEARCH  = 1, 2, 3, 4  # состояния меню
INCREMENT = {"KEY_RIGHT": 1, "\t": 1, "KEY_DOWN": 1, "KEY_LEFT": -1, "KEY_BTAB": -1, "KEY_UP": -1}  # при нажатии этих кнопок прибавляем или отнимаем позицию?
STATE = "running"  # состояние программы

SCREEN.refresh()  # не знаю зачем это нужно но без этого не работает
SCREEN.keypad(True)  # нужно для работы со стрелками
curses.set_escdelay(1) # в curses зачем-то сделали задержку на срабатывание Escape, уменьшаем её до 1 милисекунды (до 0 нельзя)
curses.curs_set(0)  # делаем курсор невидимым
curses.noecho()  # не выводим символы вверху

class Menu:
    def __init__(self, name, rows, begin_x, width, state):
        self.state = state  # состояние меню
        self.name = name  # заголовок меню
        self.rows = rows  # строки меню
        self.filter = ""  # фильтр строк меню
        self.filtered_rows = lambda: [x for x in self.rows if self.filter in x]  # отфильтрованные строки меню
        self.selected_row_index = 0  # индекс выбранной строки меню
        self.selected_row = lambda: self.filtered_rows()[self.selected_row_index]  # выбранная строка меню
        self.begin_x = begin_x  # где начинается меню по х?
        self.win = curses.newwin(curses.LINES - 3, width, 0, begin_x)  # окно с высотой во весь экран, шириной width, и началом по х в точке begin_x
        self.rows_number = curses.LINES - 9  # максимальное число видимых строк меню, начиная с 0


execute_cmd = lambda command: subprocess.check_output(command, shell=True).decode().strip().split()
api_resources_top = ["pods", "services", "deployments", "statefulsets", "daemonsets", "ingresses", "configmaps", "secrets", "persistentvolumes", "persistentvolumeclaims", "nodes", "storageclasses"]
api_resources_kubectl = execute_cmd("kubectl api-resources --no-headers --verbs=get | awk '{print $1}'")
menus = [
    Menu("Namespaces", execute_cmd("kubectl get ns --no-headers | awk '{print $1}'"), 0, curses.COLS // 10 * 2, 1),
    Menu("API resources", api_resources_top + sorted(list(set(api_resources_kubectl) - set(api_resources_top))), curses.COLS // 10 * 2, curses.COLS // 10 * 3, 3),
    Menu("Resources", [], curses.COLS // 10 * 5, curses.COLS - curses.COLS // 10 * 5, 3)
]
menus[2].rows = execute_cmd(f"kubectl get {menus[1].selected_row()} --no-headers -n {menus[0].selected_row()} | awk '{{print $1}}'")


def update_menu3():
    if not menus[0].filtered_rows() or not menus[1].filtered_rows(): menus[2].rows = ["No namespace or API resource selected"]
    else:
        menus[2].rows = execute_cmd(f"kubectl get {menus[1].selected_row()} --no-headers -n {menus[0].selected_row()} | awk '{{print $1}}'")
        if not menus[2].rows: menus[2].rows = [f"No {menus[1].selected_row()} found in {menus[0].selected_row()} namespace."]
    menus[2].selected_row_index = 0
    draw_menu(menus[2])


def draw_row(window, text, y, x, selected=False):
    window.addstr(y, x, text, curses.A_REVERSE | curses.A_BOLD if selected else curses.A_NORMAL)
    window.clrtoeol()  # очищаем остальную часть строки
    window.box()  # рисуем рамку
    window.refresh()


def draw_body_rows(menu):
    first_row_index = 0 if menu.selected_row_index < menu.rows_number else menu.selected_row_index - menu.rows_number + 1
    last_row_index = first_row_index + menu.rows_number
    selected_rows = menu.filtered_rows()[first_row_index:last_row_index]  # выбираем, от/до какой cтроки списка будет меню
    selected_row_index = menu.selected_row_index - first_row_index  # индекс выбранной строки в выбранных строках
    for index, row in enumerate(selected_rows):  # рисуем то, что отфильтровали
        draw_row(menu.win, row, index + 3, 2, selected=True if index == selected_row_index else False)


def draw_menu(menu):
    menu.win.clear()  # очищаем окно меню
    draw_row(menu.win, menu.name, 1, 2, selected=True if menu.state in [1, 2] else False)  # рисуем заголовок
    if menu.filtered_rows(): draw_body_rows(menu)  # рисуем строки меню. Если строк нет, рисовать нечего
    draw_row(menu.win, f"/{menu.filter}" if menu.state in [2, 4] else "", curses.LINES - 5, 2)  # рисуем строку поиска


def run_command(key_pressed):
    if not menus[2].filtered_rows() or menus[2].filtered_rows()[0].startswith("No ") or (key_pressed == "4" and menus[1].selected_row() != "pods"): return
    commands = {"1": f'kubectl -n {menus[0].selected_row()} get {menus[1].selected_row()} {menus[2].selected_row()} -o yaml | batcat -l yaml --paging always --style numbers',
                "2": f'kubectl -n {menus[0].selected_row()} describe {menus[1].selected_row()} {menus[2].selected_row()} | batcat -l yaml --paging always --style numbers',
                "3": f'kubectl -n {menus[0].selected_row()} edit {menus[1].selected_row()} {menus[2].selected_row()}',
                "4": f'kubectl -n {menus[0].selected_row()} logs {menus[2].selected_row()} | batcat -l log --paging always --style numbers'}
    curses.def_prog_mode()  # сохраняем преыдущее состояние терминала
    curses.endwin()  # без этого после выхода из vim начинаются проблемы
    subprocess.call(commands[key_pressed], shell=True)
    curses.reset_prog_mode()  # восстанавливаем преыдущее состояние терминала
    SCREEN.refresh()


def navigate_horizontally(key_pressed, menu):
    next_menu = menus[(menus.index(menu) + INCREMENT[key_pressed]) % 3]
    menu.state = NOT_SELECTED_WITH_SEARCH if menu.filter else NOT_SELECTED
    next_menu.state = SELECTED_WITH_SEARCH if next_menu.filter else SELECTED
    draw_row(menu.win, menu.name, 1, 2, selected=False)  # убираем выделение с заголовка текущего меню
    draw_row(next_menu.win, next_menu.name, 1, 2, selected=True)  # выделяем заголовок следующего/предыдущего меню


def navigate_vertically(key_pressed, menu):
    if not menu.filtered_rows() or len(menu.filtered_rows()) == 1: return  # если строк нет или строка одна, навигация не нужна
    menu.selected_row_index = (menu.selected_row_index + INCREMENT[key_pressed]) % len(menu.filtered_rows())  # выбираем строку учитывая сколько строк в меню
    draw_menu(menu)  # перерисовываем меню
    if menu != menus[2]: update_menu3()  # перерисовываем третье меню, т. к. оно зависит от вертикальной навигации в меню 1 и 2


def handle_selected_with_search_state(key_pressed, menu):
    if key_pressed == "\x1b": menu.filter = ""  # Нажатие Escape выходит из режима поиска
    elif key_pressed in ["KEY_BACKSPACE", "\x08"]: menu.filter = menu.filter[:-1]  # Нажатие Backspace удаляет символ
    elif key_pressed.isalpha() or key_pressed == "-": menu.filter += key_pressed.lower()
    else: return
    menu.state = SELECTED if not menu.filter else menu.state
    menu.selected_row_index = 0
    draw_menu(menu)
    if menu != menus[2]: update_menu3(menu)  # перерисовываем третье меню, т. к. оно зависит от нажатия Esc/Backspace/etc. в меню 1 и 2


def handle_selected_state(key_pressed, menu):
    if key_pressed == "/":
        menu.state = SELECTED_WITH_SEARCH
        draw_row(menu.win, "/", curses.LINES - 5, 2)  # рисуем строку поиска
    elif key_pressed.lower() == "q": globals().update(STATE="interrupt")  # выход


def catch_input(menu):
    key_pressed = SCREEN.getkey()
    if key_pressed in ["\t", "KEY_RIGHT", "KEY_BTAB", "KEY_LEFT"]: navigate_horizontally(key_pressed, menu)
    elif key_pressed in ["KEY_DOWN", "KEY_UP"]: navigate_vertically(key_pressed, menu)
    elif key_pressed in ["1", "2", "3", "4"]: run_command(key_pressed)
    elif menu.state == SELECTED_WITH_SEARCH: handle_selected_with_search_state(key_pressed, menu)
    elif menu.state == SELECTED: handle_selected_state(key_pressed, menu)


def main():
    for menu in menus: draw_menu(menu) # основные окна
    help_text = "q: exit, /: enter search mode, Esc: exit search mode, 1: get yaml, 2: describe, 3: edit, 4: pod logs, arrows/TAB: navigation"
    draw_row(curses.newwin(3, curses.COLS, curses.LINES - 3, 0), help_text, 1, 2)  # окно помощи
    while STATE == "running":
         for menu in menus:
             if menu.state in [1, 2]: catch_input(menu)  # если меню выбрано, перехватываем ввод пользователя


main()
curses.endwin()  # нужно для нормальной работы терминала после выхода
