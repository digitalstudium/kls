#!/usr/bin/env python3
import curses
import subprocess

stdscr = None
curses.set_escdelay(1)  # в curses зачем-то сделали задержку на срабатывание Escape, уменьшаем её до 1 милисекунды (до 0 нельзя)
running = True

# состояния меню
SELECTED_WITHOUT_SEARCH = 1
SELECTED_WITH_SEARCH = 2
NOT_SELECTED_WITHOUT_SEARCH = 3
NOT_SELECTED_WITH_SEARCH = 4


# я не знаю, что делается в этой функции. 
def init_screen():
    global stdscr
    stdscr = curses.initscr()
    stdscr.refresh()
    curses.noecho()
    curses.cbreak()
    stdscr.keypad(True)
    curses.curs_set(0)


init_screen()


class Menu:
    def __init__(self, name, rows, begin_x, state):
        self.state = state
        self.name = name  # заголовок окна
        self.rows = rows  # строки окна
        self.begin_x = begin_x  # где начинается окно по х?
        self.win = curses.newwin(curses.LINES, curses.COLS // 3, 0,
                                 begin_x)  # окно с высотой во весь экран, шириной экран / 3, и началом по х в точке begin_x
        self.win.box()  # ?
        self.row = 0  # выбранная строка
        self.filter = ""


# рисуем первое меню
## готовим контент
bytes_list = subprocess.check_output(
    "kubectl get ns --no-headers -o template='{{range .items}}{{.metadata.name}} {{end}}'", shell=True).split()
namespaces = [bytes_list[i].decode('utf-8') for i in range(len(bytes_list))]
## отрисовываем меню
menu1 = Menu("Namespaces", namespaces, 0, SELECTED_WITHOUT_SEARCH)

# рисуем второе меню
## готовим контент
api_resources = ["pods", "services", "deployments", "ingresses"]
## отрисовываем меню
menu2 = Menu("API resources", api_resources, 0 + curses.COLS // 3, NOT_SELECTED_WITHOUT_SEARCH)

# рисуем третье меню
## готовим контент
bytes_list = subprocess.check_output(
    "kubectl get pods -n kube-system --no-headers -o template='{{range .items}}{{.metadata.name}} {{end}}'",
    shell=True).split()
pods = [bytes_list[i].decode('utf-8') for i in range(len(bytes_list))]
## отрисовываем меню
menu3 = Menu("Resources", pods, 0 + curses.COLS // 3 * 2, NOT_SELECTED_WITHOUT_SEARCH)

menus = [menu1, menu2, menu3]


# def run_command(command, menu, rows=None):
#    namespace = menu1.rows[menu1.row]
#    api_resource = menu2.rows[menu2.row]
#    resource = menu3.rows[menu3.row]
#    subprocess.call(eval(command), shell=True)
#    init_screen()
#    for menu in menus:
#        menu.win.clear()
#        menu.win.box()
#        menu.win.addstr(1, 2, menu.name)
#        menu.win.addstr(curses.LINES - 2, 2, menu.filter)
#        if rows and menu.name == "Resources":
#            menu.rows = rows
#            menu.row = 0
#        for index, row in enumerate(menu.rows):
#            menu.win.addstr(index + 3, 2, row)
#        menu.win.addstr(menu.row + 3, 2, menu.rows[menu.row], curses.A_REVERSE | curses.A_ITALIC)
#    menu.win.addstr(1, 2, menu.name, curses.A_REVERSE | curses.A_ITALIC) 


def update_menu3():
    menu1_filtered_rows = list(filter(lambda x: (x.startswith(menu1.filter)), menu1.rows))  # фильтруем строки
    menu2_filtered_rows = list(filter(lambda x: (x.startswith(menu2.filter)), menu2.rows))  # фильтруем строки
    if not menu1_filtered_rows or not menu2_filtered_rows:
        resources = [f"No resources matched criteria.", ]
    else:
        namespace = menu1_filtered_rows[menu1.row]
        api_resource = menu2_filtered_rows[menu2.row]
        command = "f'kubectl get {api_resource} -n {namespace} --no-headers -o template=\"{{{{range .items}}}}{{{{.metadata.name}}}} {{{{end}}}}\"'"
        bytes_list = subprocess.check_output(eval(command), shell=True).split()
        resources = [bytes_list[i].decode('utf-8') for i in range(len(bytes_list))]
        if not resources:
            resources = [f"No resources found in {namespace} namespace.", ]
    menu3.rows = resources
    menu3.row = 0


def draw_menu(menu):
    draw_header(menu)  # рисуем заголовок
    draw_rows(menu)  # рисуем строки меню
    draw_search_box(menu)  # рисуем строку поиска

def draw_header(menu):
    if menu.state in [1, 2]:
        menu.win.addstr(1, 2, menu.name, curses.A_REVERSE | curses.A_ITALIC)
    else:
        menu.win.addstr(1, 2, menu.name)
    menu.win.refresh()  # обновляем окно


def draw_rows(menu):
    filtered_rows = list(filter(lambda x: (x.startswith(menu.filter)), menu.rows))  # фильтруем строки
    for index, row in enumerate(filtered_rows):  # рисуем то, что отфильтровали
        menu.win.addstr(index + 3, 2, row)
    if filtered_rows:
        menu.win.addstr(3, 2, filtered_rows[0], curses.A_REVERSE | curses.A_ITALIC)  # выделяем первую строку
    menu.win.box()
    menu.win.refresh()


def draw_search_box(menu):
    # рисуем строку поиска
    if menu.state in [2, 4]:
        content = f"/{menu.filter}"
    else:
        content = "Press / for search"
    menu.win.addstr(curses.LINES - 2, 2, content)  # рисуем контент
    menu.win.clrtoeol()  # очищаем остальную часть строки
    menu.win.box()  # рисуем рамку
    menu.win.refresh()  # обновляем окно


def catch_input(menu):
    global running
    key_pressed = stdscr.getkey()
    match key_pressed:
        case "/":
            menu.state = SELECTED_WITH_SEARCH
        case "q":
            if menu.state == 1:
                running = False
            else:
                menu.filter += key_pressed
                menu.win.clear()  # очищаю всё окно потому что лень очищать все строки только в конкретной области окна
                menu.row = 0
                draw_menu(menu)
        case "\x1b":  # Escape disables search mode
            if menu.state == SELECTED_WITH_SEARCH:
                menu.filter = ""
                menu.win.clear()
                draw_rows(menu)
                menu.state = SELECTED_WITHOUT_SEARCH
        case "KEY_BACKSPACE":
            if menu.filter:
                menu.filter = menu.filter[:-1]  # удаляем символ из строки поиска
                menu.win.clear()
                draw_menu(menu)
            else:
                menu.state = SELECTED_WITHOUT_SEARCH
        case '\t' | "KEY_RIGHT":
            navigate_horizontally("right", menu)
        case "KEY_BTAB" | "KEY_LEFT":
            navigate_horizontally("left", menu)
        case "KEY_DOWN":
            navigate_vertically("down", menu)
        case "KEY_UP":
            navigate_vertically("up", menu)
        case _:
            if menu.state == SELECTED_WITH_SEARCH and key_pressed.isalpha() or key_pressed == "-":  # объекты в кубе не могут иметь иных символов кроме a-z и -
                menu.filter += key_pressed
                menu.win.clear()
                menu.row = 0
                draw_menu(menu)
    if menu3.state not in [1, 2]:
        menu3.win.clear()
        update_menu3()
        draw_menu(menu3)


def navigate_horizontally(direction, menu):
    increment = {"right": 1, "left": -1}
    # чтобы понять, какой порядковый номер у следующего/предыдущего меню, нужно сперва определить номер текущего меню
    menu_index = {menu1: 0, menu2: 1, menu3: 2}
    next_menu = menus[(menu_index[menu] + increment[direction]) % 3]
    if menu.filter:
        menu.state = NOT_SELECTED_WITH_SEARCH
    else:
        menu.state = NOT_SELECTED_WITHOUT_SEARCH
    draw_header(menu)  # убираем выделение с текущего меню
    if next_menu.filter:
        next_menu.state = SELECTED_WITH_SEARCH
    else:
        next_menu.state = SELECTED_WITHOUT_SEARCH


def navigate_vertically(direction, menu):
    increment = {"down": 1, "up": -1}
    filtered_rows = list(filter(lambda x: (x.startswith(menu.filter)), menu.rows))  # фильтруем строки
    if not filtered_rows or len(filtered_rows) == 1:
        return
    elif filtered_rows[menu.row].startswith("No resources"):  # это касается только третьего меню
        return
    menu.win.addstr(menu.row + 3, 2, filtered_rows[menu.row])  # удаляем выделение с текущей строки
    menu.row = (menu.row + increment[direction]) % len(filtered_rows)  # переходим к предыдущей/следующей строке
    menu.win.addstr(menu.row + 3, 2, filtered_rows[menu.row], curses.A_REVERSE | curses.A_ITALIC)  # и выделяем её


def main(stdscr):
    global running
    stdscr.refresh()
    # начальный экран
    for menu in menus:
        draw_menu(menu)
    while running:
        ### выбрано первое меню ###
        menu = menu1
        if menu1.state == 1 and menu2.state == 3 and menu3.state == 3:
            draw_header(menu)  # рисуем заголовок
            draw_search_box(menu)  # рисуем строку поиска
            catch_input(menu)  # перехватываем нажатия клавиш
        elif menu1.state == 1 and menu2.state == 4 and menu3.state == 3:
            draw_header(menu)  # рисуем заголовок
            draw_search_box(menu)  # рисуем строку поиска
            catch_input(menu)  # перехватываем нажатия клавиш
        elif menu1.state == 1 and menu2.state == 3 and menu3.state == 4:
            draw_header(menu)  # рисуем заголовок
            draw_search_box(menu)  # рисуем строку поиска
            catch_input(menu)  # перехватываем нажатия клавиш
        elif menu1.state == 1 and menu2.state == 4 and menu3.state == 4:
            draw_header(menu)  # рисуем заголовок
            draw_search_box(menu)  # рисуем строку поиска
            catch_input(menu)  # перехватываем нажатия клавиш
        elif menu1.state == 2 and menu2.state == 3 and menu3.state == 3:
            draw_header(menu)  # рисуем заголовок
            draw_search_box(menu)  # рисуем строку поиска
            catch_input(menu)  # перехватываем нажатия клавиш
        elif menu1.state == 2 and menu2.state == 4 and menu3.state == 3:
            draw_header(menu)  # рисуем заголовок
            draw_search_box(menu)  # рисуем строку поиска
            catch_input(menu)  # перехватываем нажатия клавиш
        elif menu1.state == 2 and menu2.state == 3 and menu3.state == 4:
            draw_header(menu)  # рисуем заголовок
            draw_search_box(menu)  # рисуем строку поиска
            catch_input(menu)  # перехватываем нажатия клавиш
        elif menu1.state == 2 and menu2.state == 4 and menu3.state == 4:
            draw_header(menu)  # рисуем заголовок
            draw_search_box(menu)  # рисуем строку поиска
            catch_input(menu)  # перехватываем нажатия клавиш

        ### выбрано второе меню ###
        menu = menu2
        if menu1.state == 3 and menu2.state == 1 and menu3.state == 3:
            draw_header(menu)  # рисуем заголовок
            draw_search_box(menu)  # рисуем строку поиска
            catch_input(menu)  # перехватываем нажатия клавиш
        elif menu1.state == 3 and menu2.state == 1 and menu3.state == 4:
            draw_header(menu)  # рисуем заголовок
            draw_search_box(menu)  # рисуем строку поиска
            catch_input(menu)  # перехватываем нажатия клавиш
        elif menu1.state == 4 and menu2.state == 1 and menu3.state == 3:
            draw_header(menu)  # рисуем заголовок
            draw_search_box(menu)  # рисуем строку поиска
            catch_input(menu)  # перехватываем нажатия клавиш
        elif menu1.state == 4 and menu2.state == 1 and menu3.state == 4:
            draw_header(menu)  # рисуем заголовок
            draw_search_box(menu)  # рисуем строку поиска
            catch_input(menu)  # перехватываем нажатия клавиш
        elif menu1.state == 3 and menu2.state == 2 and menu3.state == 3:
            draw_header(menu)  # рисуем заголовок
            draw_search_box(menu)  # рисуем строку поиска
            catch_input(menu)  # перехватываем нажатия клавиш
        elif menu1.state == 3 and menu2.state == 2 and menu3.state == 4:
            draw_header(menu)  # рисуем заголовок
            draw_search_box(menu)  # рисуем строку поиска
            catch_input(menu)  # перехватываем нажатия клавиш
        elif menu1.state == 4 and menu2.state == 2 and menu3.state == 3:
            draw_header(menu)  # рисуем заголовок
            draw_search_box(menu)  # рисуем строку поиска
            catch_input(menu)  # перехватываем нажатия клавиш
        elif menu1.state == 4 and menu2.state == 2 and menu3.state == 4:
            draw_header(menu)  # рисуем заголовок
            draw_search_box(menu)  # рисуем строку поиска
            catch_input(menu)  # перехватываем нажатия клавиш

        ### выбрано третье меню ###
        menu = menu3
        if menu1.state == 3 and menu2.state == 3 and menu3.state == 1:
            draw_header(menu)  # рисуем заголовок
            draw_search_box(menu)  # рисуем строку поиска
            catch_input(menu)  # перехватываем нажатия клавиш
        elif menu1.state == 3 and menu2.state == 4 and menu3.state == 1:
            draw_header(menu)  # рисуем заголовок
            draw_search_box(menu)  # рисуем строку поиска
            catch_input(menu)  # перехватываем нажатия клавиш
        elif menu1.state == 4 and menu2.state == 3 and menu3.state == 1:
            draw_header(menu)  # рисуем заголовок
            draw_search_box(menu)  # рисуем строку поиска
            catch_input(menu)  # перехватываем нажатия клавиш
        elif menu1.state == 4 and menu2.state == 4 and menu3.state == 1:
            draw_header(menu)  # рисуем заголовок
            draw_search_box(menu)  # рисуем строку поиска
            catch_input(menu)  # перехватываем нажатия клавиш
        elif menu1.state == 3 and menu2.state == 3 and menu3.state == 2:
            draw_header(menu)  # рисуем заголовок
            draw_search_box(menu)  # рисуем строку поиска
            catch_input(menu)  # перехватываем нажатия клавиш
        elif menu1.state == 3 and menu2.state == 4 and menu3.state == 2:
            draw_header(menu)  # рисуем заголовок
            draw_search_box(menu)  # рисуем строку поиска
            catch_input(menu)  # перехватываем нажатия клавиш
        elif menu1.state == 4 and menu2.state == 3 and menu3.state == 2:
            draw_header(menu)  # рисуем заголовок
            draw_search_box(menu)  # рисуем строку поиска
            catch_input(menu)  # перехватываем нажатия клавиш
        elif menu1.state == 4 and menu2.state == 4 and menu3.state == 2:
            draw_header(menu)  # рисуем заголовок
            draw_search_box(menu)  # рисуем строку поиска
            catch_input(menu)  # перехватываем нажатия клавиш


#        if current_menu == 0:
#            if key_pressed == "/":
#                search_mode = True
#            if search_mode:
#                match key_pressed:
#                    case '\t' | "KEY_RIGHT":
#                        current_menu = navigate_horizontally("right", current_menu)
#                    case "KEY_BTAB" | "KEY_LEFT":
#                        current_menu = navigate_horizontally("left", current_menu)
#                    case "KEY_DOWN":
#                        navigate_vertically("down", current_menu)
#                    case "KEY_UP":
#                        navigate_vertically("up", current_menu)
#                    case "KEY_BACKSPACE":
#                        if filter:
#                            filter = filter[:-1]
#                        else:
#                            search_mode = False
#                if key_pressed.isalpha() or key_pressed == "-":
#                    filter += key_pressed
#                elif key_pressed == "/" and filter == "":
#                    pass
#                else:
#                    continue
#                init_screen()
#                for menu in menus:
#                    menu.win.clear()  # очищаем окно
#                    menu.win.box()
#                    menu.win.addstr(1, 2, menu.name) # добавляем заголовок окна
#                    if menu.name == "Namespaces":
#                        menu.rows = list(filter(lambda x: (x.startswith(filter)), namespaces))  # меняем строки у окна Namespaces
#                        menu.row = 0
#                        if search_mode:
#                            menu.win.addstr(curses.LINES - 2, 2, f"/{filter}")
#                        else:
#                            menu.win.addstr(curses.LINES - 2, 2, "Press / for search")
#                    elif menu.name == "Resources":
#                        if menus[0].rows:
#                            namespace = menus[0].rows[menus[0].row]
#                            api_resource = menus[1].rows[menus[1].row]
#                            command = "f'kubectl get {api_resource} -n {namespace} --no-headers -o template=\"{{{{range .items}}}}{{{{.metadata.name}}}} {{{{end}}}}\"'"
#                            bytes_list = subprocess.check_output(eval(command), shell=True).split()
#                            resources = [bytes_list[i].decode('utf-8') for i in range(len(bytes_list))]
#                            if not resources:
#                                resources = [f"No resources found in {namespace} namespace.",]
#                        else:
#                            resources = ["No namespace selected",]
#                        menu.rows = resources
#
#                    for index, row in enumerate(menu.rows):
#                        menu.win.addstr(index + 3, 2, row)
#                    if menu.rows:
#                        menu.win.addstr(3, 2, menu.rows[menu.row], curses.A_REVERSE | curses.A_ITALIC) # выделяем первую строку
#                menus[current_menu].win.addstr(1, 2, menus[current_menu].name, curses.A_REVERSE | curses.A_ITALIC) # помечаем выбранное меню
#                continue
#
#        match key_pressed:
#            case 'q': 
#                running = False
#            case '/': 
#                search_mode = True
#            case 'g': 
#                if current_menu == 2 and not menus[2].rows[menus[2].row].startswith("No resources"):
#                    run_command("f'kubectl -n {namespace} get {api_resource} {resource} -o yaml | batcat -l yaml --paging always --style numbers'", current_menu)
#            case 'd': 
#                if current_menu == 2 and not menus[2].rows[menus[2].row].startswith("No resources"):
#                    run_command("f'kubectl -n {namespace} describe {api_resource} {resource} | batcat -l yaml --paging always --style numbers'", current_menu)
#            case 'l': 
#                if current_menu == 2 and not menus[2].rows[menus[2].row].startswith("No resources") and menus[1].rows[menus[1].row] == "pods":
#                    run_command("f'kubectl -n {namespace} logs {resource} | batcat -l log --paging always --style numbers'", current_menu)
#            case 'e': 
#                if current_menu == 2 and not menus[2].rows[menus[2].row].startswith("No resources"):
#                    run_command("f'kubectl edit {api_resource} -n {namespace} {resource}'", current_menu)
#            case '\t' | "KEY_RIGHT":
#                current_menu = navigate_horizontally("right", current_menu)
#            case "KEY_BTAB" | "KEY_LEFT":
#                current_menu = navigate_horizontally("left", current_menu)
#            case "KEY_DOWN":
#                navigate_vertically("down", current_menu)
#            case "KEY_UP":
#                navigate_vertically("up", current_menu)
# main(stdscr)
curses.wrapper(main)

# curses.nocbreak()
# stdscr.keypad(False)
# curses.echo()
# curses.endwin()
# subprocess.call(["clear"])
#
