#!/usr/bin/env python3
import curses, subprocess


class Menu:
    def __init__(self, title, rows, begin_x, width):
        self.title, self.rows, self.filter = title, rows, ""
        self.filtered_rows = lambda: [x for x in self.rows if self.filter in x]  # отфильтрованные строки меню
        self.selected_row_index = 0  # индекс выбранной строки меню
        self.selected_row = lambda: self.filtered_rows()[self.selected_row_index]  # выбранная строка меню
        self.begin_x = begin_x  # где начинается меню по х?
        self.win = curses.newwin(curses.LINES - 3, width, 0, begin_x)  # окно с высотой во весь экран, шириной width, и началом по х в точке begin_x


SCREEN = curses.initscr()  # инициализация экрана
execute_cmd = lambda command: subprocess.check_output(command, shell=True).decode().rstrip().split("\n")  # вывод команды преобразуем в list
api_resources_top = ["pods", "services", "deployments", "statefulsets", "daemonsets", "ingresses", "configmaps", "secrets", "persistentvolumes", "persistentvolumeclaims", "nodes", "storageclasses"]
api_resources_kubectl = execute_cmd("kubectl api-resources --no-headers --verbs=get | awk '{print $1}'")
MENUS = [Menu("Namespaces", execute_cmd("kubectl get ns --no-headers | awk '{print $1}'"), 0, curses.COLS // 6),
        Menu("API resources", api_resources_top + sorted(list(set(api_resources_kubectl) - set(api_resources_top))), curses.COLS // 6, curses.COLS // 4),
        Menu("Resources", [], curses.COLS // 6 + curses.COLS // 4, curses.COLS - (curses.COLS // 6 + curses.COLS // 4))]
SELECTED_MENU = MENUS[0]
HELP_TEXT = "q: exit, /: enter filter mode, Esc: exit filter mode, 1: get yaml, 2: describe, 3: edit, 4: pod logs, arrows/TAB: navigation"
ROWS_NUMBER = curses.LINES - 9  # максимальное число видимых строк меню, начиная с 0


def update_menu3():
    if not MENUS[0].filtered_rows() or not MENUS[1].filtered_rows(): MENUS[2].rows = ["No namespace or API resource selected"]
    elif MENUS[1].selected_row() == "pods": MENUS[2].rows = execute_cmd(f"kubectl -n {MENUS[0].selected_row()} get pods --no-headers | awk '{{ printf \"%70s %10s\\n\", $1,$3 }}'")
    else: MENUS[2].rows = execute_cmd(f"kubectl -n {MENUS[0].selected_row()} get {MENUS[1].selected_row()} --no-headers | awk '{{print $1}}'")
    if MENUS[2].rows == ['']: MENUS[2].rows = [f"No {MENUS[1].selected_row()} found in {MENUS[0].selected_row()} namespace."]
    MENUS[2].selected_row_index = 0  # перед перерисовкой сбрасываем выбранную строку на 0
    draw_menu(MENUS[2])


def draw_row(window, text, y, x, selected=False):
    window.addstr(y, x, text, curses.A_REVERSE | curses.A_BOLD if selected else curses.A_NORMAL)
    window.refresh()


def draw_menu(menu):
    menu.win.clear()  # очищаем окно меню
    draw_row(menu.win, menu.title, 1, 2, selected=True if menu == SELECTED_MENU else False)  # рисуем заголовок
    if menu.filtered_rows():  # рисуем строки меню. Если строк нет, рисовать нечего
        first_row_index = 0 if menu.selected_row_index < ROWS_NUMBER else menu.selected_row_index - ROWS_NUMBER + 1
        selected_rows = menu.filtered_rows()[first_row_index:][:ROWS_NUMBER]  # выбираем, от/до какой cтроки списка будет меню
        selected_row_index = menu.selected_row_index - first_row_index  # индекс выбранной строки в выбранных строках
        for index, row in enumerate(selected_rows):  # рисуем то, что отфильтровали
            draw_row(menu.win, row, index + 3, 2, selected=True if index == selected_row_index else False)
    draw_row(menu.win, f"/{menu.filter}" if menu.filter else "", curses.LINES - 5, 2)  # рисуем строку поиска
    if menu != MENUS[2]: update_menu3()  # перерисовываем третье меню, если мы перерисовали первое или второе меню


def run_command(key_pressed):
    if MENUS[2].filtered_rows()[0].startswith("No ") or (key_pressed == "4" and MENUS[1].selected_row() != "pods"): return
    commands = {"1": f'get {MENUS[1].selected_row()} {MENUS[2].selected_row().split()[0]} -o yaml | batcat -l yaml --paging always --style numbers',
                "2": f'describe {MENUS[1].selected_row()} {MENUS[2].selected_row().split()[0]} | batcat -l yaml --paging always --style numbers',
                "3": f'edit {MENUS[1].selected_row()} {MENUS[2].selected_row().split()[0]}',
                "4": f'logs {MENUS[2].selected_row().split()[0]} | batcat -l log --paging always --style numbers'}
    curses.def_prog_mode()  # сохраняем преыдущее состояние терминала
    curses.endwin()  # без этого после выхода из vim начинаются проблемы
    subprocess.call(f"kubectl -n {MENUS[0].selected_row()} " + commands[key_pressed], shell=True)
    curses.reset_prog_mode()  # восстанавливаем преыдущее состояние терминала
    SCREEN.refresh()


def handle_selected_with_filter_state(key_pressed, menu):
    match key_pressed:
        case "\x1b": menu.filter = ""  # Нажатие Escape выходит из режима поиска
        case "KEY_BACKSPACE" | "\x08": menu.filter = menu.filter[:-1]  # Нажатие Backspace удаляет символ (\x08 это тоже Backspace)
        case key_pressed if key_pressed.isalpha() or key_pressed == "-": menu.filter += key_pressed.lower()
        case _: return
    menu.selected_row_index = 0
    draw_menu(menu)


def catch_input(menu):
    key_pressed = SCREEN.getkey()
    filter_mode = "/" in chr(menu.win.inch(curses.LINES - 5, 2))  # если слэш уже нарисован, значит мы в режиме фильтра
    match key_pressed:
        case "\t"| "KEY_RIGHT" | "KEY_BTAB" | "KEY_LEFT":
            next_menu = MENUS[(MENUS.index(menu) + {"KEY_RIGHT": 1, "\t": 1, "KEY_LEFT": -1, "KEY_BTAB": -1}[key_pressed]) % 3]
            draw_row(menu.win, menu.title, 1, 2, selected=False)  # убираем выделение с заголовка текущего меню
            draw_row(next_menu.win, next_menu.title, 1, 2, selected=True)  # выделяем заголовок следующего/предыдущего меню
            globals().update(SELECTED_MENU=next_menu)
        case "KEY_DOWN" | "KEY_UP" if len(menu.filtered_rows()) > 1:
            menu.selected_row_index = (menu.selected_row_index + {"KEY_DOWN": 1, "KEY_UP": -1}[key_pressed]) % len(menu.filtered_rows())  # учитываем, сколько строк в меню
            draw_menu(menu)  # перерисовываем меню
        case "1" | "2" | "3" | "4" if MENUS[2].filtered_rows(): run_command(key_pressed)
        case "q" | "Q" if not filter_mode: globals().update(SELECTED_MENU=None) # выход
        case "/" if not filter_mode: draw_row(menu.win, "/", curses.LINES - 5, 2)  # рисуем строку поиска
        case _ if filter_mode: handle_selected_with_filter_state(key_pressed, menu)


def main(screen):
    SCREEN.refresh()  # не знаю зачем это нужно но без этого не работает
    SCREEN.keypad(True)  # нужно для работы со стрелками
    curses.set_escdelay(1)  # в curses зачем-то сделали задержку на срабатывание Escape, уменьшаем её до 1 милисекунды (до 0 нельзя)
    curses.curs_set(0)  # делаем курсор невидимым
    curses.use_default_colors()  # не меняем цвет терминала
    curses.noecho()  # не выводим символы вверху
    for menu in MENUS:
        draw_menu(menu) # рисуем основные окна
    draw_row(curses.newwin(3, curses.COLS, curses.LINES - 3, 0), HELP_TEXT, 1, 2)  # и окно помощи
    while SELECTED_MENU:
        catch_input(SELECTED_MENU)  # если какое-то меню выбрано, перехватываем ввод пользователя

curses.wrapper(main)
