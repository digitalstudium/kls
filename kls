#!/usr/bin/env python3
import subprocess, curses


class Menu:
    def __init__(self, title, rows, begin_x, width):
        self.title = title
        self.rows = rows  # все строки
        self.filter = ""  # фильтр строк
        self.filtered_rows = lambda: [x for x in self.rows if self.filter in x]  # фильтрованные строки
        self.filtered_row_index = 0  # индекс выбранной строки из фильтрованных строк
        # __start_index - начиная с какой строки мы будем выбирать строки из filtered_rows()? Обычно с первой строки,
        # но если размер filtered_rows больше HEIGHT и filtered_row_index выходит за границы высоты меню HEIGHT,
        # сдвигаем __start_index вправо на filtered_row_index - HEIGHT. Таким образом реализуется прокрутка меню
        self.__start_index = lambda: 0 if self.filtered_row_index < HEIGHT else self.filtered_row_index - HEIGHT + 1
        self.visible_rows = lambda: self.filtered_rows()[self.__start_index():][:HEIGHT]  # видимые строки
        self.__visible_row_index = lambda: self.filtered_row_index - self.__start_index()  # индекс выбранной строки из видимых строк
        self.selected_row = lambda: self.visible_rows()[self.__visible_row_index()] if self.visible_rows() else None  # выбранная строка из видимых строк
        self.win = curses.newwin(curses.LINES - 3, width, 0, begin_x)


SCREEN = curses.initscr()  # инициализация экрана
# вывод команды преобразуем в list
kubectl = lambda command: subprocess.check_output("kubectl " + command, shell=True).decode().rstrip().split("\n")
api_resources_top = ["pods", "services", "ingresses", "deployments", "statefulsets", "daemonsets", "configmaps",
                     "secrets", "persistentvolumes", "persistentvolumeclaims", "nodes", "storageclasses"]
api_resources_kubectl = kubectl("api-resources --no-headers --verbs=get | awk '{print $1}'")
api_resources = list(dict.fromkeys(api_resources_top + api_resources_kubectl))  # так top api ресурсы будут вверху
width_unit = curses.COLS // 8
MENUS = [Menu("Namespaces", kubectl("get ns --no-headers -o custom-columns=NAME:.metadata.name"), 0, width_unit),
         Menu("API resources", api_resources, width_unit, width_unit * 2),
         Menu("Resources", [], width_unit * 3, curses.COLS - width_unit * 3)]
SELECTED_MENU = MENUS[0]
HELP_TEXT = "Esc: exit filter mode or exit kls, 1: get yaml, 2: describe, 3: edit, 4: pod logs, arrows/TAB: navigation"
HEIGHT = curses.LINES - 9  # максимальное число индексов видимых строк
namespace = MENUS[0].selected_row  # псеводним метода
api_resource = MENUS[1].selected_row
resource = lambda: MENUS[2].selected_row().split()[0]


def update_menu3():
    if namespace() and api_resource():
        columns_dict = {"pods": 'NAME:.metadata.name,STATUS:.status.phase,NODE:.spec.nodeName',
                        "services": 'NAME:.metadata.name,TYPE:.spec.type,CLUSTER_IP:.spec.clusterIP',
                        "ingresses": 'NAME:.metadata.name,HOSTS:.spec.rules[*].host',
                        "persistentvolumeclaims": 'NAME:.metadata.name,SIZE:.spec.resources.requests.storage,STORAGE_CLASS:.spec.storageClassName'}
        columns = columns_dict.get(api_resource(), 'NAME:.metadata.name')
        MENUS[2].rows = kubectl(f"-n {namespace()} get {api_resource()} --no-headers -o custom-columns={columns}")
        MENUS[2].rows = [x for x in MENUS[2].rows if x]  # это нужно для удаления пустых значений из листа
    else:
        MENUS[2].rows = []
    MENUS[2].filtered_row_index = 0  # перед перерисовкой сбрасываем выбранную строку на 0
    draw_menu(MENUS[2])


def draw_row(window, text, y, x, selected=False):
    window.addstr(y, x, text, curses.A_REVERSE | curses.A_BOLD if selected else curses.A_NORMAL)
    window.clrtoeol()
    window.refresh()


def draw_rows(rows, menu):
    for index, row in enumerate(rows):
        draw_row(menu.win, row, index + 3, 2, selected=True if row == menu.selected_row() else False)


def draw_menu(menu):
    menu.win.clear()  # очищаем окно меню
    draw_row(menu.win, menu.title, 1, 2, selected=True if menu == SELECTED_MENU else False)  # рисуем заголовок
    draw_rows(menu.visible_rows(), menu)  # рисуем строки меню
    draw_row(menu.win, f"/{menu.filter}" if menu.filter else "", curses.LINES - 5, 2)  # рисуем строку поиска


def run_command(key):
    if key == "4" and api_resource() != "pods":
        return
    batcat_cmd = lambda lang: f'batcat -l {lang} --paging always --style numbers'
    commands = {
        "1": f'get {api_resource()} {resource()} -o yaml | {batcat_cmd("yaml")}',
        "2": f'describe {api_resource()} {resource()} | {batcat_cmd("yaml")}',
        "3": f'edit {api_resource()} {resource()}',
        "4": f'logs {resource()} | {batcat_cmd("log")}'}
    curses.def_prog_mode()  # сохраняем преыдущее состояние терминала
    curses.endwin()  # без этого после выхода из vim начинаются проблемы
    subprocess.call(f"kubectl -n {namespace()} " + commands[key], shell=True)
    curses.reset_prog_mode()  # восстанавливаем преыдущее состояние терминала
    SCREEN.refresh()


def handle_filter_state(key, menu):
    if key == "\x1b":
        menu.filter = ""  # Нажатие Escape выходит из режима поиска
    elif key in ["KEY_BACKSPACE", "\x08"]:
        menu.filter = menu.filter[:-1]  # Нажатие Backspace удаляет символ (\x08 это тоже Backspace)
    elif key.isalpha() or key == "-":
        menu.filter += key.lower()
    else:
        return
    menu.filtered_row_index = 0
    draw_menu(menu)
    if menu != MENUS[2]:
        update_menu3()  # перерисовываем строки третьего меню, если мы перерисовали строки первого или второго меню


def catch_input(menu):
    key = SCREEN.getkey()
    if key in ["\t", "KEY_RIGHT", "KEY_BTAB", "KEY_LEFT"]:
        increment = {"KEY_RIGHT": 1, "\t": 1, "KEY_LEFT": -1, "KEY_BTAB": -1}[key]
        next_menu = MENUS[(MENUS.index(menu) + increment) % 3]
        draw_row(menu.win, menu.title, 1, 2, selected=False)  # убираем выделение с заголовка текущего меню
        # и выделяем заголовок нового меню
        draw_row(next_menu.win, next_menu.title, 1, 2, selected=True)
        globals().update(SELECTED_MENU=next_menu)
    elif key in ["KEY_UP", "KEY_DOWN"] and len(menu.visible_rows()) > 1:
        increment = {"KEY_DOWN": 1, "KEY_UP": -1}[key]
        menu.filtered_row_index = (menu.filtered_row_index + increment) % len(menu.filtered_rows())
        draw_rows(menu.visible_rows(), menu)  # перерисовываем меню
        if menu != MENUS[2]:
            update_menu3()  # перерисовываем строки третьего меню, если мы перерисовали строки первого или второго меню
    elif key in ["1", "2", "3", "4"] and MENUS[2].selected_row():
        run_command(key)
    elif key == "\x1b" and not menu.filter:
        globals().update(SELECTED_MENU=None)  # выход
    else:
        handle_filter_state(key, menu)


def main(screen):
    SCREEN.refresh()  # не знаю зачем это нужно но без этого не работает
    SCREEN.keypad(True)  # нужно для работы со стрелками
    # в curses зачем-то сделали задержку на срабатывание Escape, уменьшаем её до 1 милисекунды (до 0 нельзя)
    curses.set_escdelay(1)
    curses.curs_set(0)  # делаем курсор невидимым
    curses.use_default_colors()  # не меняем цвет терминала
    curses.noecho()  # не выводим символы вверху
    draw_menu(MENUS[0])  # рисуем основные окна
    draw_menu(MENUS[1])
    update_menu3()
    draw_row(curses.newwin(3, curses.COLS, curses.LINES - 3, 0), HELP_TEXT, 1, 2)  # и окно помощи
    while SELECTED_MENU:
        catch_input(SELECTED_MENU)  # если какое-то меню выбрано, перехватываем ввод пользователя


curses.wrapper(main)
